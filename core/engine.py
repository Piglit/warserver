#!/usr/bin/python3
"""This is the ArtOffWar game module.
Here the map and the game state is represented.
Other modules communicate with this module to read and to write the game state.
"""

import time
import threading
import random
import copy
from collections import Counter
import Pyro4


__author__ 	= "Pithlit"
__version__	= 0.0

#not used now, but these strings are diplayed in Artemis when you transmit the corresponding numbers
terrain_types = {
	"Sector":					0,		
	"Nebula":			   		1,	
	"Minefield":				2,	
	"Asteroid Belt":			3,	
	"Black Hole Nursery":   	4,	
	"Wildlands":				5,	
	"Crossroads":		   		6,	
}


class Game:
	"""
	A class for WarServer driven games.
	An object of this class represents the game state.
	This implementation reassembles the original Artemis WarServer.
	There are some fixed activaded per default. Deactivate them via settings.
	There are some options, you can activate via settings.
	"""

	def __init__(self, settings):
		self.settings = {
			"Game Difficulty Level":	7,
			"Invaders Per Turn":		20,
			"Invasion Beachheads":		1,
			"Empty Sectors":			7,	#This is more exactly than in the original WarServer.
			"Total Turns":				5,
			"Minutes per Turn":			5,	#accepts float
			"Minutes between Turns (interlude)":	1,	#accepts float
			"Bugfix: Beachheads off by one":	True,	#Probably a bug in the original WarServer.
			"Randomize Beachheads":		False,
			"Neighbours":	[(0,0),(1,0),(-1,0),(0,1)],	#in the original WarServer enemies never go to the north.
			"Hidden Sectors cant be Neighbours":	False,	#set to True to calculate enemies distribution from non hidden sectors only. False behaves like the original WarServer.
			"Non Reentrant Sectors":	False,	#if True only one client can enter each sector.
			"Clients have own Maps":	False,
		}
		self.settings.update(settings)

		assert(self.settings["Invasion Beachheads"] <= 8)
		assert(self.settings["Invasion Beachheads"] >= 0)
		if self.settings["Bugfix: Beachheads off by one"]:
			beachhead_columns = [3,4,2,5,1,6,0,7]
		else:
			beachhead_columns = [4,5,3,6,2,7,1,0]
		if self.settings["Randomize Beachheads"]:
			random.shuffle(beachhead_columns)
		beachhead_columns = beachhead_columns[0:self.settings["Invasion Beachheads"]]
	
		self.beachheads = []
		for bc in beachhead_columns:
			self.beachheads.append((bc,0))
			#default beachheads generated by config file are always on the first row
			#Game Master can rearrange them or place them on any sector of the map
		del self.settings["Invasion Beachheads"]
		del self.settings["Randomize Beachheads"]
		del self.settings["Bugfix: Beachheads off by one"]
		#these were settings that only matter on startup
		#deleting them removes confusing the gm, when she reads the settings
	
		self.map = []
		for col in range(0,8):
			self.map.append([])
			for row in range(0,8):
				sector = {
					"Enemies":			0,
					"Rear_Bases":		random.randrange(4),	#0 to 3
					"Forward_Bases":	random.randrange(2),	#0 to 1
					"Fire_Bases":		0,
					"Terrain":			random.randrange(7),	
					"Seed":				random.randrange(16**4),
					"Difficulty_mod":	0,	# self.settings["Game Difficulty Level"] is added to determine the difficulty level. GM may change this value for each sector
					"??":				0,	#TODO
					"Hidden":			False,
					"Name":				"Sector",
					"pending_invaders":	0,	#should be only visible to GM
					"blocked":			False, #only visible to GM. prevents entering the sector
				}
				self.map[col].append(sector)
			assert len(self.map[col]) == 8
		assert len(self.map) == 8

		hidden_sector_columns = Counter()
		for i in range(self.settings["Empty Sectors"]):
			hidden_sector_columns[random.randrange(8)] += 1
		for col, num in hidden_sector_columns.most_common():
			for sector in random.sample(self.map[col][1:],min(num,len(self.map[col]))):
				sector["Hidden"] = True
		del self.settings["Empty Sectors"]	#irrelevant from now on

		self.turn = {
			"turn_number":	1,
			"max_turns":	self.settings["Total Turns"],
			"interlude":	False,
			"turn_started":	time.time()
		}
		del self.settings["Total Turns"]	#irrelevant from now on

		self.ships = dict()
		self.base_points = 0
		self.scoreboard_kills = Counter()
		self.scoreboard_clears= Counter()
		self.lock = threading.RLock()
		self.notifications = []
		self.timer_thread = threading.Timer(self.settings["Minutes per Turn"]*60, self._next_turn)
		for i in range(6):
			self._defeat_bases(self.map)
			self._enemies_proceed(self.map)
			self._enemies_spawn(self.map)
		self.timer_thread.start()
		print("Game Engine started")

	# getter methods

	def get_map(self,client=None):
		"""
		Returns the whole map.
		It is used to show the map to Artemis clients or to manage an admiral or GM Screen.
		With client=None the whole map is returned, so the caller decides what information is used.
		If client is a tuple: (ip_address, port) or a string like "admirals_map", 
		this method may decide to restrict information, depending on who is requesting the map.
		"""
		with self.lock:
			return self.map 
			#warning: the caller may change the map. You may prevent this by returning a copy of the map. See deepcopy()

	def get_turn_status(self, client=None):
		"Returns the turn dict with the seconds remaining as float"
		with self.lock:
			turn = self.turn
			remaining = turn["turn_started"] - time.time()
			if turn["interlude"]:
				remaining += self.settings["Minutes between Turns (interlude)"] * 60
			else:
				remaining += self.settings["Minutes per Turn"] * 60
			turn["remaining"] = remaining	#updated only when this is called!
			return turn

	def get_ships(self, client=None):
		with self.lock:
			return self.ships

	def get_base_points(self, client=None):
		with self.lock:
			return self.base_points

	def get_scoreboard(self, client=None):
		with self.lock:
			return (self.scoreboard_clears, self.scoreboard_kills)

	def get_settings(self, client=None):
		with self.lock:
			return self.settings

	def get_beachheads(self, client=None):
		with self.lock:
			return self.beachheads
		

	#setter methods

	def update_sector(self, x, y, key, value):
		"""sets one value of a sector. Used for GM or Admiral."""
		with self.lock:
			assert type(self.map[x][y][key]) == type(value) , "value has the wrong type"
			self.map[x][y][key] = value

	def change_sector(self, x, y, key, diff):
		"""
		changes one value of a sector. Used for GM or Admiral.
		To prevent race conditions change_sector sould be used instead of update_sector from connected clients.
		"""
		with self.lock:
			assert type(self.map[x][y][key]) == type(diff) , "value has the wrong type"
			self.map[x][y][key] += diff

	def change_base_points(self,diff):
		"""changes base points about diff"""
		with self.lock:
			self.base_points += diff

	def change_turn_number(self, n):
		with self.lock:
			self.turn["turn_number"] += n

	def change_max_turns(self, n):
		with self.lock:
			self.turn["max_turns"] += n

	def end_turn(self):
		with self.lock:
			self._next_turn()

	def change_turn_time_remaining(self,seconds):
		with self.lock:
			self.timer_thread.cancel()
			self.turn['turn_started'] += seconds
			turn = self.get_turn_status()
			if turn["remaining"] > 0:
				self.timer_thread = threading.Timer(turn["remaining"], self._next_turn)
				self.timer_thread.start()
			else:
				self._next_turn()

	def change_setting(self,setting,value):
		with self.lock:
			try:
				assert(type(self.settings[key]) == type(value))
				self.settings[key] += value
			except Exception as e:
				print(e)

	def set_setting(self,setting,value):
		with self.lock:
			try:
				assert(type(self.settings[key]) == type(value))
				self.settings[key] == value
			except Exception as e:
				print(e)

	def change_scoreboard_kills(self,shipname,value):
		with self.lock:
			self.scoreboard_kills[shipname] += value

	def change_scoreboard_clears(self,shipname,value):
		with self.lock:
			self.scoreboard_clears[shipname] += value

	def add_beachhead(self,x,y):
		#there one beachhead may occure multiple times in this list. this results in a higher amount of enemies in that sector
		with self.lock:
			return self.beachheads.append((x,y))

	def remove_beachhead(self,x,y):
		#removes the first occurence of the beachhead from the list.
		with self.lock:
			if (x,y) in self.beachheads:
				self.beachheads.remove((x,y))

	#artemis connected interaction

	def enter_sector(self,x,y,shipname,client):
		"""
		This is called when an Artemis client enters a sector.
		Returns the sector as dict.
		The implementation may decide to send other data then shown on the map.
		You may also alter the shipname here to avoid collisions.
		You can return None, to forbid that client enters that setor now.
		"""
		with self.lock:
			if client in self.ships:
				self.ships[client] = (shipname,-1,-1,0,0)	#invalidate, since client is not in a sector right now
			if self.settings["Non Reentrant Sectors"]:
				for key in self.ships:
					if self.ships[key][1] == x and self.ships[key][2] == y:
						return None	#Sector Forbidden 
			sector = copy.deepcopy(self.map[x][y])
			if sector["Enemies"] <= 0:
				return None	#Dont enter sectors without enemies
			if sector["Hidden"]:
				return None	#Dont enter hidden sectors
			if sector["blocked"]:
				return None	#Dont enter sectors blocked by GM
			sector.update({
				"ID":			random.randrange(16**4),
				"Ship-Name":	"Tessel",
				"Difficulty":	self.settings["Game Difficulty Level"] + sector["Difficulty_mod"],
			})
			if sector.get("Ship-Name") is not None:
				shipname = sector["Ship-Name"]
			self.ships[client] = (shipname,x,y,sector["ID"],sector["Enemies"])
			self._map_changed()
		print(sector)
		print(shipname + " entered sector " + chr(x+ord('A')) + str(y) +"." )
		return sector

	def clear_sector(self,shipname,id,client):
		"""
		This is called after an Artemis client sends an leave sector packet.
		The client has defeated all enemies in that sector.
		"""
		with self.lock:
			assert client in self.ships
			battle = self.ships[client]
			x = battle[1]
			y = battle[2]
			self.scoreboard_kills[shipname] += battle[4]
			self.ships[client] = (shipname,-1,-1,0,0)
			if self.map[battle[1]][battle[2]]["Enemies"] > 0:
				self.change_base_points(1)
				self.scoreboard_clears[shipname] += 1
			self.map[battle[1]][battle[2]]["Enemies"] = 0
			self._map_changed()
		print(shipname + " cleared sector " + chr(x+ord('A')) + str(y) +"." )

	def kills_in_sector(self,shipname,id,kills,client):
		"""
		This is called after an Artemis client killed one or more enemies.
		The client still resides in that sector.
		"""
		with self.lock:
			assert client in self.ships
			battle = self.ships[client]
			assert battle[0] == shipname
			assert battle[3] == id
			self.ships[client] = (battle[0], battle[1], battle[2], battle[3], battle[4]-kills)
			self.scoreboard_kills[shipname] += kills
		print(shipname + " defeated " + str(kills) + " enem" + ("y" if kills == 1 else "ies") + " in sector " + chr(battle[1]+ord('A')) + str(battle[2]) +"." )

	def disconnect_client(self, client):
		"""When a client disconects, free the sector"""
		with self.lock:
			if client in self.ships:
				self.ships[client] = (shipname,-1,-1,0,0)


	# varios methods

	def register_notification(self,event):
		"""
		The caller mat provide an event to the engine, which is set when the map changes.
		The caller must clear his event himself.
		"""
		self.notifications.append(event)

	def _map_changed(self):
		"""Called to notify other modules that the map has changed"""
		for e in self.notifications:
			e.set()

	def _next_turn(self):
		"""proceeds to the next turn"""
		with self.lock:
			self.timer_thread.cancel()	#ignored if this is executed by the timer_thread itself
			self.turn["turn_started"] = time.time()
			if self.turn["interlude"]:
				if self.turn["turn_number"] <= self.turn["max_turns"]:
					self.turn["interlude"] = False 
					self.timer_thread = threading.Timer(self.settings["Minutes per Turn"]*60, self._next_turn)
				else:
					self.timer_thread = threading.Timer(self.settings["Minutes between Turns (interlude)"]*60, self._next_turn)
			else:
				self._defeat_bases(self.map)
				self._enemies_proceed(self.map)
				self._enemies_spawn(self.map)
				for client in self.ships:
					self.ships[client] = (self.ships[client][0],-1,-1,0,0)	#clear all the shipnames
				self.turn["turn_number"] += 1
				self.turn["interlude"] = True
				self.timer_thread = threading.Timer(self.settings["Minutes between Turns (interlude)"]*60, self._next_turn)
			self.timer_thread.start()
			self._map_changed()	#awakens notify thread. Turn over is sent.

	def _defeat_bases(self,map):
		"""
		Destroys all bases in sectors where enemies are.
		The map given as argument is modified in-place.
		You may call this method with a copy of the games map,
		so you can see what happens without modifying the actual map.
		"""
		with self.lock:
			for column in map:
				for sector in column:
					if sector["Enemies"] > 0:
						sector["Rear_Bases"] = 0
						sector["Forward_Bases"] = 0
						sector["Fire_Bases"] = 0

	def _enemies_spawn(self,map):
		"""
		Enemies enter the map.
		The map given as argument is modified in-place.
		You may call this method with a copy of the games map,
		so you can see what happens without modifying the actual map.
		"""
		with self.lock:
			enemies = self.settings["Invaders Per Turn"] // len(self.beachheads)
			plus_one = self.settings["Invaders Per Turn"] % len(self.beachheads)
			for x,y in self.beachheads:
				map[x][y]["Enemies"] += enemies
				if plus_one > 0:
					map[x][y]["Enemies"] += 1
					plus_one -= 1

			
	def _enemies_proceed(self,map):
		"""
		Enemies move around.
		The map given as argument is modified in-place.
		You may call this method with a copy of the games map,
		so you can see what happens without modifying the actual map.
		"""
		with self.lock:
			for col in range(8):
				for row in range(8):
					sector = map[col][row]
					neighbours = self._neighbours(col,row)
					enemies = sector["Enemies"] // len(neighbours)
					for t in copy.copy(neighbours):
						x,y = t
						if x < 0 or x > 7 or y < 0 or y > 7:
							neighbours.remove(t)
						elif map[x][y]["Hidden"]:
							neighbours.remove(t)
					if self.settings["Hidden Sectors cant be Neighbours"]:
						enemies = sector["Enemies"] // len(neighbours)
					for t in neighbours:
						x,y = t
						map[x][y]["pending_invaders"] += enemies
						sector["Enemies"] -= enemies
			for col in range(8):
				for row in range(8):
					map[col][row]["Enemies"] += map[col][row]["pending_invaders"]
					map[col][row]["pending_invaders"] = 0

	def _neighbours(self, x_0, y_0):
		result = []
		for x_1,y_1 in self.settings["Neighbours"]:
			result.append((x_0+x_1, y_0+y_1))
		return result

#game=Game({})
game=None

def start_game(settings):
	#TODO ignored by now
	global game
	if settings == None:
		settings = {}
	game=Game(settings)
